<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> ç¥è´¾æ¢¦æœˆåœ£è¯å¿«ä¹</title>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; background: #000; font-family: "Microsoft YaHei", sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute; width: 100%; top: 45%; text-align: center;
            color: #2ecc71; pointer-events: none; z-index: 100;
        }
        .fade-text {
            font-size: 2.2rem; font-weight: bold; opacity: 0;
            text-shadow: 0 0 20px rgba(46, 204, 113, 0.8);
            transition: opacity 1.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="text" class="fade-text"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const config = {
            mainGreen: 0x2ecc71,  // ç¿¡ç¿ ç»¿
            lightGreen: 0xa8ffcf, // é«˜å…‰ç»¿
            layers: 9,            // å¯¹åº”ç…§ç‰‡ä¸­çš„å±‚çº§æ„Ÿ
            particleCount: 35000,
            snowCount: 1200
        };

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 1. ç‹¬ç«‹é›ªèŠ±ç³»ç»Ÿï¼ˆä»å¤´å¼€å§‹ï¼‰ ---
        let snowPoints;
        function initSnow() {
            const snowGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < config.snowCount; i++) {
                positions.push((Math.random()-0.5)*250, Math.random()*150, (Math.random()-0.5)*250);
            }
            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            snowPoints = new THREE.Points(snowGeo, new THREE.PointsMaterial({
                color: 0xffffff, size: 0.18, transparent: true, opacity: 0.8
            }));
            scene.add(snowPoints);
        }

        function updateSnow() {
            const pos = snowPoints.geometry.attributes.position.array;
            for (let i = 1; i < pos.length; i += 3) {
                pos[i] -= 0.08; 
                if (pos[i] < -60) pos[i] = 80;
            }
            snowPoints.geometry.attributes.position.needsUpdate = true;
        }

        // --- 2. ç¥ç¦è¯­é€»è¾‘ ---
        const greetings = [
            "âœ¨ è´¾æ¢¦æœˆ âœ¨",
            "åœ¨è¿™ä¸ªç‰¹åˆ«çš„å¤œæ™š",
            "æƒ³é€ä½ ä¸€ä»½ä¸ä¸€æ ·çš„æƒŠå–œ",
            "æ„¿ä½ å²å²å¹³å®‰ï¼Œä¸‡äº‹é¡ºé‚",
            "ğŸ„ åœ£è¯å¿«ä¹ ğŸ„"
        ];
        let currentIdx = 0;
        const textEl = document.getElementById('text');

        function showGreetings() {
            if (currentIdx < greetings.length) {
                textEl.innerText = greetings[currentIdx];
                textEl.style.opacity = 1;
                setTimeout(() => {
                    textEl.style.opacity = 0;
                    setTimeout(() => { currentIdx++; showGreetings(); }, 1200);
                }, 2500);
            } else {
                initTreeScene(); // æ–‡å­—æ’­å®Œåæ˜¾ç° 3D åœ£è¯æ ‘
            }
        }

        // --- 3. åœ£è¯æ ‘ï¼šè¿˜åŸç…§ç‰‡å½¢çŠ¶ ---
        let treePoints, ringGroup, topHeart;
        let treeVisible = false;

        function initTreeScene() {
            const treeGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < config.particleCount; i++) {
                // æ¨¡æ‹Ÿç…§ç‰‡ä¸­åˆ†æ®µè£™æ‘†çš„æ•ˆæœ
                const layer = Math.floor(Math.random() * config.layers);
                const hBase = layer * 3.2;
                const hRelative = Math.random() * 3.2;
                const h = hBase + hRelative;
                
                // æ¯ä¸€å±‚åº•éƒ¨æ‰©å¼ ï¼Œå½¢æˆæ˜æ˜¾çš„å±‚å åˆ†ç•Œ
                const layerMaxR = (config.layers - layer) * 1.6;
                const r = layerMaxR * (1 - hRelative/3.5) * Math.pow(Math.random(), 0.6);
                const angle = Math.random() * Math.PI * 2;

                positions.push(Math.cos(angle)*r, h - 14, Math.sin(angle)*r);
                
                const mixColor = new THREE.Color(config.mainGreen).lerp(new THREE.Color(config.lightGreen), Math.random() * 0.5);
                colors.push(mixColor.r, mixColor.g, mixColor.b);
            }
            treeGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            treeGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            treePoints = new THREE.Points(treeGeo, new THREE.PointsMaterial({
                size: 0.12, vertexColors: true, transparent: true, opacity: 0, blending: THREE.AdditiveBlending
            }));
            scene.add(treePoints);

            // åœ°é¢åŒå¿ƒåœ†å…‰ç¯ï¼ˆç»¿è‰²ï¼‰
            ringGroup = new THREE.Group();
            for(let r=5; r<18; r+=4) {
                const ringGeo = new THREE.BufferGeometry();
                const rPos = [];
                for(let j=0; j<r*120; j++){
                    const a = (j/(r*120)) * Math.PI * 2;
                    rPos.push(Math.cos(a)*r, -14, Math.sin(a)*r);
                }
                ringGeo.setAttribute('position', new THREE.Float32BufferAttribute(rPos, 3));
                const ring = new THREE.Points(ringGeo, new THREE.PointsMaterial({ color: config.mainGreen, size: 0.08, transparent: true, opacity: 0 }));
                ringGroup.add(ring);
            }
            scene.add(ringGroup);

            // æ ‘é¡¶å¿ƒå½¢
            const heartShape = new THREE.Shape();
            heartShape.moveTo(0, 0);
            heartShape.bezierCurveTo(0, 0.5, 1.5, 2, 0, 3.5);
            heartShape.bezierCurveTo(-1.5, 2, 0, 0.5, 0, 0);
            topHeart = new THREE.Mesh(new THREE.ShapeGeometry(heartShape), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0 }));
            topHeart.scale.set(0.6, 0.6, 0.6);
            topHeart.rotation.z = Math.PI;
            topHeart.position.set(0, 16, 0);
            scene.add(topHeart);

            treeVisible = true;
        }

        camera.position.set(0, 0, 48);

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            updateSnow(); // é›ªèŠ±å§‹ç»ˆé£˜è½

            if (treeVisible) {
                // åœ£è¯æ ‘æ¸æ˜¾æ•ˆæœ
                if (treePoints.material.opacity < 0.9) {
                    treePoints.material.opacity += 0.01;
                    topHeart.material.opacity += 0.01;
                    ringGroup.children.forEach(r => r.material.opacity += 0.005);
                }

                treePoints.rotation.y += 0.005;
                ringGroup.rotation.y += 0.002;
                
                // å¿ƒå½¢å‘¼å¸åŠ¨ç”»
                const s = 0.6 + Math.sin(time * 3) * 0.1;
                topHeart.scale.set(s, s, s);
                topHeart.rotation.y += 0.02;
            }

            renderer.render(scene, camera);
        }

        // åˆå§‹åŒ–å¯åŠ¨
        initSnow();
        showGreetings();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>